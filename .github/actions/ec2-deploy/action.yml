---
name: "Deploy to EC2"
description: "Deploys application to EC2 instance using Docker Compose"

inputs:
  host:
    required: true
    description: "EC2 host address"
  username:
    required: true
    description: "SSH username"
  key:
    required: true
    description: "SSH private key"
  docker_username:
    required: true
    description: "Docker Hub username"
  db_password:
    required: true
    description: "Database password"
  weatherbit_api_key:
    required: true
    description: "Weatherbit API key"

runs:
  using: "composite"
  steps:
    - name: Validate inputs
      shell: bash
      run: |
        # Validate and log input values
        echo "Validating deployment inputs..."

        # Validate SSH inputs
        if [ -z "${{ inputs.host }}" ]; then
          echo "Error: SSH host is empty"
          exit 1
        fi
        echo "SSH host is set"

        if [ -z "${{ inputs.username }}" ]; then
          echo "Error: SSH username is empty"
          exit 1
        fi
        echo "SSH username is set"

        if [ -z "${{ inputs.key }}" ]; then
          echo "Error: SSH key is empty"
          exit 1
        fi
        echo "SSH key is set"

        if [ -z "${{ inputs.docker_username }}" ]; then
          echo "Error: DOCKER_USERNAME is empty"
          exit 1
        fi
        echo "DOCKER_USERNAME is set to: ${{ inputs.docker_username }}"

        echo "All required inputs validated successfully"

    - name: Setup SSH
      shell: bash
      run: |
        # Create SSH directory
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh

        # Write the private key to a file
        echo "${{ inputs.key }}" > ~/.ssh/ec2_key
        chmod 600 ~/.ssh/ec2_key

        # Add host key to known hosts to prevent verification prompt
        ssh-keyscan -H ${{ inputs.host }} >> ~/.ssh/known_hosts

    - name: Create environment file
      shell: bash
      run: |
        # Create .env.local from .env.ci template
        cp .env.ci .env.local

        # Replace placeholders with actual inputs
        sed -i "s/\${DB_PASSWORD}/${{ inputs.db_password }}/g" .env.local
        sed -i "s/\${WEATHERBIT_API_KEY}/${{ inputs.weatherbit_api_key }}/g" .env.local
        cat .env.local

    - name: Copy files to EC2
      shell: bash
      run: |
        # Create a temporary directory for deployment files
        mkdir -p ~/deploy-temp
        cp docker-compose.yml Dockerfile requirements.txt .env.ci .env.local ~/deploy-temp/
        cp -r scripts/ ~/deploy-temp/
        cp main.py ~/deploy-temp/

        # Ensure static directory exists and is copied
        mkdir -p static
        cp -r static/ ~/deploy-temp/

        # Copy .env.ci for the Dockerfile
        cp .env.ci ~/deploy-temp/.env.ci

        # Copy all files to EC2
        scp -i ~/.ssh/ec2_key -r ~/deploy-temp/* ${{ inputs.username }}@${{ inputs.host }}:~/thunder-buddy/
        scp -i ~/.ssh/ec2_key -r ~/deploy-temp/.env.ci ${{ inputs.username }}@${{ inputs.host }}:~/thunder-buddy/
        scp -i ~/.ssh/ec2_key -r ~/deploy-temp/.env.local ${{ inputs.username }}@${{ inputs.host }}:~/thunder-buddy/
        echo "All deployment files copied to EC2"

    - name: Deploy to EC2
      uses: appleboy/ssh-action@v0.1.9
      with:
        host: ${{ inputs.host }}
        username: ${{ inputs.username }}
        key: ${{ inputs.key }}
        script_stop: true
        envs: |
          DOCKER_USERNAME=${{ inputs.docker_username }}
          DB_PASSWORD=${{ inputs.db_password }}
        script: |
          echo "Starting remote deployment process..."
          echo "Creating thunder-buddy directory..."
          mkdir -p ~/thunder-buddy
          cd ~/thunder-buddy

          echo "Setting up environment..."
          export DOCKER_USERNAME=${{ inputs.docker_username }}
          export DB_PASSWORD=${{ inputs.db_password }}
          export WEATHERBIT_API_KEY=${{ inputs.weatherbit_api_key }}

          echo "Stopping existing containers (preserving volumes)..."
          docker compose down --remove-orphans || true
          # Remove only containers, not volumes
          docker rm -f thunder-buddy thunder-buddy-db || true

          echo "Pulling and starting containers..."
          docker compose pull
          docker compose up -d

          echo "Waiting for services to be healthy..."
          # Wait for DB to be ready (max 60 seconds instead of 30)
          echo "Waiting for database to be ready..."
          timeout 60 bash -c 'until docker exec thunder-buddy-db pg_isready -U thunderbuddy -d thunderbuddy; do sleep 2; echo "Waiting for database..."; done'
          if [ $? -ne 0 ]; then
            echo "Error: Database failed to become ready"
            docker compose logs db
            exit 1
          fi
          echo "Database is ready"

          # Check if app container is running and can connect to DB
          echo "Waiting for application to become healthy..."

          # Get the actual host port that's mapped to container port 5000
          APP_PORT=$(docker inspect --format='{{(index (index .NetworkSettings.Ports "5000/tcp") 0).HostPort}}' thunder-buddy)
          echo "Application is mapped to host port: $APP_PORT"

          # Check if container is running
          echo "Container status:"
          docker ps | grep thunder-buddy

          # Check container logs
          echo "Container logs:"
          docker logs thunder-buddy --tail 50

          # Check container network settings
          echo "Container network settings:"
          docker inspect thunder-buddy --format='{{json .NetworkSettings.Networks}}' | jq

          # Check if the container is listening on port 5000
          echo "Checking if container is listening on port 5000:"
          docker exec thunder-buddy netstat -tulpn | grep 5000 || echo "netstat not found, trying ss" && docker exec thunder-buddy ss -tulpn | grep 5000 || echo "Port 5000 not found in listening ports"

          # Try to access the health endpoint from inside the container
          echo "Trying to access health endpoint from inside the container:"
          docker exec thunder-buddy curl -v http://0.0.0.0:5000/health || echo "curl failed inside container"

          # Check if the application started properly
          echo "Checking if Flask application started:"
          docker exec thunder-buddy ps aux | grep python || echo "ps not found, trying pgrep" && docker exec thunder-buddy pgrep -a python || echo "No Python processes found"

          # Increase timeout for health check (from 30 to 60 iterations)
          for i in {1..60}; do
            echo "Health check attempt $i/60..."
            HEALTH_RESPONSE=$(curl -v http://localhost:$APP_PORT/health)
            echo "Health response: $HEALTH_RESPONSE"
            
            if echo "$HEALTH_RESPONSE" | grep -q "healthy"; then
              echo "Application is healthy"
              break
            fi
            
            if [ $i -eq 60 ]; then
              echo "Error: Application failed to become healthy after 60 attempts"
              echo "Checking database connection from inside container..."
              docker exec thunder-buddy python -c "from scripts.db import test_connection; print(test_connection())" || echo "Failed to run database connection test"
              
              # Check if the database is accessible from the app container
              echo "Testing database connectivity from app container:"
              docker exec thunder-buddy pg_isready -h db -U thunderbuddy -d thunderbuddy || echo "Database connectivity test failed"
              
              docker compose logs
              exit 1
            fi
            sleep 2
          done

          # Final connectivity test
          echo "Testing service connectivity..."
          FINAL_HEALTH=$(curl -v http://localhost:$APP_PORT/health)
          echo "Final health check response: $FINAL_HEALTH"

          if ! echo "$FINAL_HEALTH" | grep -q "healthy"; then
            echo "Error: Application health check failed"
            docker compose logs
            exit 1
          fi
          echo "Deployment completed successfully!"
